## 스프링은 Framework 이다.

- Frame : 틀     
- work : 수행하다.      
틀 안에서 동작하며 틀을 벗어나지 않는다.

## 스프링은 오픈소스이다.

오픈 소스란 소스코드가 공개되어 누구나 내부를 볼 수 있는 코드이다.     
이는 곧 내부를 뜯어 고쳐서 기여(수정)할 수 있다는 것이다.     

## 스프링은 IoC 컨테이너를 가진다.     

- Inversion of Control: 제어의 역전. 제어 반전     
- 컨테이너: 객체의 생명주기를 관리, 생성된 인스턴스들에게 추가적인 기능을 제공하도록 하는 것.     

제어를 역전한다는 것은 객체의 생성, 생명주기의 관리까지 모든 객체에 대한 제어권이 바뀌었다는 것을 의미한다.    
즉, 스프링의 IoC컨테이너는 인스턴스 생성부터 소멸까지의 인스턴스 생명주기 관리를 개발자가 아닌 컨테이너가 대신 해준다는 것이다.     
전통적인 프로그래밍에서 흐름은 개발자가 작성한 프로그램이 외부 라이브러리의 코드를 호출해 이용한다.    
하지만 제어 반전이 적용된 구조에서는 외부 라이브러리의 코드가 개발자가 작성한 코드를 호출한다.      
객체관리의 주체가 프레임워크(Container)가 되므로 개발자는 로직에 집중할 수 있다.     

 - IoC 컨테이너는 객체의 생성을 책임지고 의존성을 관리한다.       
 - POJO의 생성, 초기화, 서비스, 소멸에 대한 권한을 가진다.(Plain old Java Object)       
 - 개발자가 직접 POJO를 생성할 수 있지만 컨테이너에게 맡긴다.     
 - POJO란 특정 자바 모델이나 기능, 프레임워크를 따르지 않는 Java Object를 지칭한다. Java Bean, getter, setter가 대표적이다.     
 
 
 - 작업을 구현하는 방식과 작업 수행 자체를 분리한다.      
 - 모듈을 제작할 때, 모듈과 외부 프로그램의 결합에 대해 고민한 필요 없이 모듈의 목적에 집중할 수 있다.     
 - 다른 시스템이 어떻게 동작할지에 대해 고민할 필요 없이, 미리 정해진대로만 동작하게 하면 된다.     
 - 모듈을 바꾸어도 다른 시스템에 부작용을 일으키지 않는다.    
 
## 스프링은 DI를 지원한다.

- Dependency Injection: 의존성 주입. 객체 간의 의존성(객체 간의 관계맺음)을 객체 내부에서 직접 해주는 대신, 외부에서 객체를 생성해서 넣어주는 방식.      
- 의존성 주입 스프링은 싱글턴 패턴을 사용하여 객체를 어디서든 사용할 수 있다. 한 번 생성한 객체를 공유해서 사용한다.    

```java
// static 이므로 객체를 1개만 생성할 수 있도록 지정한다.
private static final SingletonService instance = new SingletonService();

// static method를 통해서만 객체를 생성할 수 있도록 한다.
public static SingletonService getInstance(){
	return instance;
}

// private 생성자를 통해서 외부에서 new로 객체생성하는 것을 막는다.
private SingletonService(){}

//싱글턴 패턴을 적용한 객체 생성
@Test
void singletonContainer(){
	SingletonService singletonService1 = SingletonService.getInstance();
	SingletonService singletonService2 = SingletonService.getInstance();
}
```


의존성 주입의 조건
- 클래스 모델이나 코드는 런타임 시점의 의존관계가 드러나지 않는다. 그러기 위해서는 인터페이스만 의존하고 있어야 한다.     
- 런타임 시점의 의존관계는 컨테이너나 팩토리 같은 제 3의 존재가 결정한다.     
- 의존관계는 사용할 Object에 대한 reference를 외부에서 제공(주입)해줌으로써 만들어진다.     


의존관계 역전의 원칙
객체 지향 프로그래밍에서 의존관계 역전 원칙은 소프트웨어 모듈들을 분리하는 특정 형식을 지칭한다.    
이 원칙을 따르면, 상위 계층(정책 결정)이 하위 계층(세부 사항)에 의존하는 전통적인 의존관계를 반전(역전)시킴으로써       
상위 계층이 하위 계층의 구현으로부터 독립되게 할 수 있다.       
첫째, 상위 모듈은 하위 모듈에 의존해서는 안된다. 상위 모듈과 하위 모듈 모두 추상화에 의존해야 한다.     
둘째, 추상화는 세부 사항에 의존해서는 안된다. 세부사항이 추상화에 의존해야 한다.    
이 원칙은 상위와 하위 객체 모두가 동일한 추상화에 의존해야 한다는 객체 지향적 설계의 대원칙을 제공한다.     


DI 장점     
- 의존성이 줄어든다. DI로 구현하게 되었을 때, 주입받는 대상이 변하더라도 구현 자체를 수정할 일이 없거나 줄어든다.       
- 재사용성이 높은 코드가 된다. 사용한 뒤 다른 클래스에서 재사용할 수가 있다.     
- 테스트하기 좋은 코드가 된다. 분리해서 각각 테스트가 가능하다.     
- 가독성이 높아진다. 기능들을 별도로 분리하여 가독성이 높아진다.     


## 스프링은 검열의 기능을 하는 필터들을 가지고 있다.

스프링 자체의 필터를 사용할 수도 있고 생성해야 사용할 수도 있다.     
톰켓의 필터는 이름이 filter이고 web.xml로 작성된다.    

- 인터셉터Interceptor: 컨트롤러Controller의 핸들러Handler를 호출하기 전과 후에 요청과 응답을 참조하거나 가공할 수 있는 일종의 필터.       

Interceptor는 Controller에 들어오는 HttpRequest와 Controller가 응답하는 HttpResponse를 가로채는 역할을 한다.      
권한 체크, 로그인 체크 등의 기능을 수행한다.    

## 스프링은 많은 애너테이션을 가지고 있다.

- 애너테이션 annotation: 주석과 같으나 컴파일러가 무언가 체크할 수 있도록 힌트를 준다.      
스프링에서는 주로 애너테이션을 이용해 객체 생성을 한다.(ex. @component, @Bean, @Controller)

- 리플렉션: 리플렉션은 구체적인 클래스 타입을 알지 못해도, 그 클래스의 메서드, 타입, 변수들을 접근할 수 있도록 해주는 API이다.     
런타임시 클래스를 스캔하여 필요한 정보를 분석한다. 접근 제어자와 관계 없이 필드와 메서드에 접근하여 필요한 작업을 수행할 수 있는 유연성을 가지고 있다.
